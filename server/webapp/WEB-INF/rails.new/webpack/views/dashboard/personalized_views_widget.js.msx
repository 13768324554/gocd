/*
 * Copyright 2018 ThoughtWorks, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const m                            = require('mithril');
const Stream                       = require('mithril/stream');
const _                            = require('lodash');
const $                            = require('jquery');
const PersonalizeWidget            = require('views/dashboard/personalize_widget');
const PipelineSelectionVM          = require('views/dashboard/models/pipeline_selection_view_model');
const PipelineSelection            = require('models/dashboard/pipeline_selection');
const PersonalizeEditorVM          = require('views/dashboard/models/personalize_editor_vm');
const PersonalizationModalWidget   = require('views/dashboard/personalization_modal_widget');
const Modal                        = require("views/shared/schmodal");

const PersonalizedViewsWidget = {
  oninit(vnode) {
    const self = vnode.state;
    self.pipelineSelection   = Stream();
    self.pipelineSelectionVM = new PipelineSelectionVM();
    self.dropdown = vnode.attrs.tabDropdown;
    self.ready = Stream(false);
    self.pipelinesByGroup = {};

    PipelineSelection.get().then((selection) => {
      selection.setCurrentFilter(vnode.attrs.currentTab());
      self.pipelineSelection(selection);
      self.pipelinesByGroup = selection.pipelineGroups();
      self.pipelineSelectionVM.initialize(selection.pipelineGroups());
      self.ready = Stream(true);
    }).then(m.redraw);


    self.personalizeEditor = function personalizeEditor(template) {
      const model = new PersonalizeEditorVM(template, self.pipelinesByGroup);
      const existing = template.name;

      new Modal({
        title: existing ? `Edit ${template.name}`: "Create new view",
        size: "personalize-editor",
        body: () => {
          return <PersonalizationModalWidget model={model}/>;
        },
        buttons: [{text: "Apply", onclick: () => {
          const previousFilterSet = self.pipelineSelection().filters;
          const updated = previousFilterSet.clone();
          const newFilter = model.asFilter();

          if (existing) {
            updated.replaceFilter(existing, newFilter);
          } else {
            updated.addFilter(newFilter);
          }

          self.pipelineSelection().filters = updated;
          self.pipelineSelection().update().done(() => {
            self.pipelineSelection().setCurrentFilter(newFilter.name);
            vnode.attrs.doRefreshImmediately();
            window.location.search = m.buildQueryString({viewName: newFilter.name});
          }).fail(() => {
            self.pipelineSelection().filters = previousFilterSet;
          }).always(() => {
            Modal.close();
            m.redraw();
          });
        }}, {text: "Cancel", class: "btn-link"}]
      });
    };

    this.editDropdown = (e) => {
      self.dropdown.show();
      e.stopPropagation();
    };

    this.preventPropagation = (e) => {
      e.stopPropagation();
    };

    this.switchTab = (e) => {
      let tabName = $(e.target).text();
      if (tabName === "default") {
        tabName = null;
      }
      window.location.search = m.buildQueryString({viewName: tabName});
    };
  },

  view(vnode) {
    const self              = vnode.state;
    const pipelineSelection = self.pipelineSelection();

    let personalizeView;

    if (vnode.attrs.isOpen()) {
      personalizeView = (<PersonalizeWidget pipelineSelection={self.pipelineSelection}
                                            widgetOpen={vnode.attrs.isOpen}
                                            doRefreshImmediately={vnode.attrs.doRefreshImmediately}
                                            hideSelectionDropdown={vnode.attrs.hideSelectionDropdown}
                                            vm={self.pipelineSelectionVM}/>);
    }

    let tabs;

    let editTabDropdown;
    if (self.dropdown.isOpen()) {
      editTabDropdown = (
        <div class="edit-dropdown" onclick={self.preventPropagation}>
          more to come
          <i class="fa fa-edit" onclick={() => { self.personalizeEditor(pipelineSelection.currentFilter.definition()); } }/>
          <i class="fa fa-trash" />
        </div>
      );
    }

    if (self.ready()) {
      tabs = _.map(pipelineSelection.displayNames(), (filterName) => {
        if (pipelineSelection.currentFilter.displayName() === filterName) {
          return (
            <div class="dashboard-tab current">
            <i class="fa fa-bars drag-icon" />
            <div class="tab-name">{filterName}</div>
            <div class="tab-dropdown">
              <i class="fa fa-caret-down dropdown-btn"
                onclick={this.editDropdown.bind(this)} />
              {editTabDropdown}
            </div>
            </div>
          );
        } else {
          return (
            <div class="dashboard-tab">
              <i class="fa fa-bars drag-icon" />
              <div class="tab-name"
                onclick={this.switchTab.bind(this)}>
                {filterName}
              </div>
            </div>
          );
        }
      });
    }

    return (
      <div class="dashboard-tabs">
        {tabs}
        <div class="add-tab"
          onclick={() => { self.personalizeEditor({}); }}>
          <i class="fa fa-plus" />
        </div>
        {personalizeView}
      </div>
    );
  }
};

module.exports = PersonalizedViewsWidget;
